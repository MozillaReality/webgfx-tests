<!DOCTYPE html>
<html lang="en">
	<head>
		<title>drawcall</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#fff;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
			}
		</style>
	</head>
	<body>

		<script id="vertexShader" type="x-shader/x-vertex">
precision highp float;
precision highp int;

attribute vec3 position;
attribute vec3 normal;

uniform mat4 modelViewMatrix;
uniform mat3 normalMatrix;
uniform mat4 projectionMatrix;

varying vec3 vNormal;

void main() {

	vec3 objectNormal = vec3( normal );
	vec3 transformedNormal = normalMatrix * objectNormal;
	vNormal = normalize( transformedNormal );

	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;

}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;
precision highp int;

varying vec3 vNormal;

vec3 packNormalToRGB( const in vec3 normal ) {

	return normalize( normal ) * 0.5 + 0.5;

}

void main() {

	vec3 normal = normalize( vNormal );
	gl_FragColor = vec4( packNormalToRGB( normal ), 1.0 );

}
		</script>

		<script>

function Vector3( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

}

Object.assign( Vector3.prototype, {

} );

function Quaternion( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

}

Object.assign( Quaternion.prototype, {

} );

function Matrix3() {

	this.elements = [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	];

}

Object.assign( Matrix3.prototype, {

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	setFromMatrix4: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) {

			var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

} );

function Matrix4() {

	this.elements = [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	];

}

Object.assign( Matrix4.prototype, {

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		var te = this.elements;

		var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		var x2 = x + x,	y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		var sx = scale.x, sy = scale.y, sz = scale.z;

	        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
	        te[ 1 ] = ( xy + wz ) * sx;
	        te[ 2 ] = ( xz - wy ) * sx;
	        te[ 3 ] = 0;

	        te[ 4 ] = ( xy - wz ) * sy;
	        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
	        te[ 6 ] = ( yz + wx ) * sy;
	        te[ 7 ] = 0;

	        te[ 8 ] = ( xz + wy ) * sz;
	        te[ 9 ] = ( yz - wx ) * sz;
	        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
	        te[ 11 ] = 0;

	        te[ 12 ] = position.x;
	        te[ 13 ] = position.y;
	        te[ 14 ] = position.z;
	        te[ 15 ] = 1;

	        return this;

	}

} );

function Object3D() {

	this.parent = null;
	this.children = [];

	var position = new Vector3();
	var quaternion = new Quaternion();
	var scale = new Vector3( 1, 1, 1 );

	Object.defineProperties( this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );

	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

}

Object3D.DefaultMatrixAutoUpdate = true;

Object.assign( Object3D.prototype, {

	add: function ( object ) {

		object.parent = this;
		this.children.push( object );

		return this;

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	}

} );
		</script>

		<script>

			function loadOption( key ) {

				var options = location.href.split( '?' )[ 1 ];

				if ( ! options ) return null;

				var optionArray = options.split( '&' );

				for ( var i = 0, il = optionArray.length; i < il; i ++ ) {

					var tmp = optionArray[ i ].split( '=' );

					if ( tmp[ 0 ].toLowerCase() === key ) return tmp[ 1 ];

				}

				return null;

			}

			var objectNum = parseInt( loadOption( 'num' ) ) || 10;
			var objects;
			var container, canvas, gl;

			var positionData, normalData, indexData;

			var cameraProjectionMatrix = new Matrix4();
			cameraProjectionMatrix.set(
				0.8864625814548678, 0, 0, 0,
				0, 1.7320508075688774, 0, 0,
				0, 0, -1.0002000200020003, -2.000200020002,
				0, 0, -1 , 0
			);

			var cameraMatrixWorldInverse = new Matrix4();
			cameraMatrixWorldInverse.set(
				1, 0, 0, 0,
				0, 1, 0, -1.6,
				0, 0, 1, 0,
				0, 0, 0, 1
			);

			var float32ArrayMatrix3 = new Float32Array( 9 );
			var float32ArrayMatrix4 = new Float32Array( 16 );

			var glPositionBuffer, glNormalBuffer, glIndexBuffer, glProgram;
			var glAttributeLocations = {};
			var glUniformLocations = {};

			var windowWidth = window.innerWidth;
			var windowHeight = window.innerHeight;
			var devicePixelRatio = window.devicePixelRatio;

			loadData( function () {

				init();
				initWebGLResources();
				animate();

			} );

			function loadData( onLoad ) {

				var request = new XMLHttpRequest();
				request.open( 'GET', 'suzanne.json', true );
				request.responseType = 'json';

				request.addEventListener( 'load', function ( event ) {

					var response = request.response;
					positionData = new Float32Array( response.position );
					normalData = new Float32Array( response.normal );
					indexData = new Uint16Array( response.index );

					expandData( 1000 );

					onLoad();

				} );

				request.addEventListener( 'error', function ( event ) {

					console.error( event );

				} );

				request.addEventListener( 'abort', function ( event ) {

					console.error( event );

				} );

				request.send( null );
			}

			function expandData( n ) {

				var positionDataLength = positionData.length;
				var normalDataLength = normalData.length;
				var indexDataLength = indexData.length;

				var newPositionData = new Float32Array( positionDataLength * n );
				var newNormalData = new Float32Array( normalDataLength * n );
				var newIndexData = new Uint16Array( indexDataLength * n );

				for ( var i = 0; i < n; i ++ ) {

					for ( var j = 0; j < positionDataLength; j ++ ) {

						newPositionData[ positionDataLength * i + j ] = positionData[ j ] + i * 0.001;

					}

					for ( var j = 0; j < normalDataLength; j ++ ) {

						newNormalData[ normalDataLength * i + j ] = normalData[ j ];

					}

					for ( var j = 0; j < indexDataLength; j ++ ) {

						newIndexData[ indexDataLength * i + j ] = indexData[ j ] + indexDataLength * i;

					}

				}

				positionData = newPositionData;
				normalData = newNormalData;
				indexData = newIndexData;

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = windowWidth * devicePixelRatio;
				canvas.height = windowHeight * devicePixelRatio;
				canvas.style.width = windowWidth + 'px';
				canvas.style.height = windowHeight + 'px';

				gl = canvas.getContext( 'webgl' );
				gl.viewport( 0, 0, windowWidth * devicePixelRatio, windowHeight * devicePixelRatio );

				container.appendChild( canvas );

				root = new Object3D();

				objects = [];

				for ( var i = 0; i < objectNum; i ++ ) {

					var object = new Object3D();

					object.position.x = Math.random() * 1000 - 500;
					object.position.y = Math.random() * 1000 - 500;
					object.position.z = Math.random() * 1000 - 500 - 3000;
					object.scale.x = object.scale.y = object.scale.z = Math.random() * 50 + 100;
					object.updateMatrix();
					object.matrixAutoUpdate = false;
					objects.push( object );

					root.add( object );

				}

				objects.sort( function ( a, b ) { return b.position.z - a.position.z; } );

				root.updateMatrixWorld( true );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function initWebGLResources() {

				// initialize configurations

				gl.disable( gl.BLEND );
				gl.enable( gl.CULL_FACE );
				gl.enable( gl.DEPTH_TEST );
				gl.depthFunc( gl.LEQUAL );
				gl.depthMask( true );
				gl.colorMask( true, true, true, true );

				// initialize vertex and fragment shaders

				var vertexShaderCode = document.getElementById( 'vertexShader' ).text;
				var fragmentShaderCode = document.getElementById( 'fragmentShader' ).text;

				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
				gl.shaderSource( vertexShader, vertexShaderCode );
				gl.compileShader( vertexShader );

				if ( ! gl.getShaderParameter( vertexShader, gl.COMPILE_STATUS ) ) {

					console.error( gl.getShaderInfoLog( vertexShader ) );

				}

				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
				gl.shaderSource( fragmentShader, fragmentShaderCode );
				gl.compileShader( fragmentShader );

				if ( ! gl.getShaderParameter( fragmentShader, gl.COMPILE_STATUS ) ) {

					console.error( gl.getShaderInfoLog( fragmentShader ) );

				}

				// initialize program

				glProgram = gl.createProgram();
				gl.attachShader( glProgram, vertexShader );
				gl.attachShader( glProgram, fragmentShader );

				gl.linkProgram( glProgram );

				if ( ! gl.getProgramParameter( glProgram, gl.LINK_STATUS ) ) {

					console.error( gl.getProgramInfoLog( glProgram ) );

				}

				glAttributeLocations.position = gl.getAttribLocation( glProgram, 'position' );
				glAttributeLocations.normal = gl.getAttribLocation( glProgram, 'normal' );

				glUniformLocations.modelViewMatrix = gl.getUniformLocation( glProgram, 'modelViewMatrix' );
				glUniformLocations.normalMatrix = gl.getUniformLocation( glProgram, 'normalMatrix' );
				glUniformLocations.projectionMatrix = gl.getUniformLocation( glProgram, 'projectionMatrix' );

				// initialize buffers

				glPositionBuffer = gl.createBuffer();
				gl.bindBuffer( gl.ARRAY_BUFFER, glPositionBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, positionData, gl.STATIC_DRAW );

				glNormalBuffer = gl.createBuffer();
				gl.bindBuffer( gl.ARRAY_BUFFER, glNormalBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, normalData, gl.STATIC_DRAW );

				glIndexBuffer = gl.createBuffer();
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, glIndexBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW );

				//

				gl.useProgram( glProgram );
				gl.enableVertexAttribArray( glAttributeLocations.position );
				gl.enableVertexAttribArray( glAttributeLocations.normal );

			}

			function onWindowResize() {

				windowWidth = window.innerWidth;
				windowHeight = window.innerHeight;

				canvas.width = windowWidth * devicePixelRatio;
				canvas.height = windowHeight * devicePixelRatio;
				canvas.style.width = windowWidth + 'px';
				canvas.style.height = windowHeight + 'px';

				gl.viewport( 0, 0, windowWidth * devicePixelRatio, windowHeight * devicePixelRatio );

				// @TODO update cameraProjectionMatrix

			}

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT );

				// bind buffer just once for all objects

				gl.bindBuffer( gl.ARRAY_BUFFER, glPositionBuffer );
				gl.vertexAttribPointer( glAttributeLocations.position, 3, gl.FLOAT, false, 0, 0 );

				gl.bindBuffer( gl.ARRAY_BUFFER, glNormalBuffer );
				gl.vertexAttribPointer( glAttributeLocations.normal, 3, gl.FLOAT, false, 0, 0 );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, glIndexBuffer );

				float32ArrayMatrix4.set( cameraProjectionMatrix.elements );
				gl.uniformMatrix4fv( glUniformLocations.projectionMatrix, false, float32ArrayMatrix4 );

				var count = indexData.length;

				for ( var i = 0, il = objects.length; i < il; i ++ ) {

					var object = objects[ i ];

					object.modelViewMatrix.multiplyMatrices( cameraMatrixWorldInverse, object.matrixWorld );
					float32ArrayMatrix4.set( object.modelViewMatrix.elements );
					gl.uniformMatrix4fv( glUniformLocations.modelViewMatrix, false, float32ArrayMatrix4 );

					object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
					float32ArrayMatrix3.set( object.normalMatrix.elements );
					gl.uniformMatrix3fv( glUniformLocations.normalMatrix, false, float32ArrayMatrix3 );

					gl.drawElements( gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0 );

				}

			}

		</script>

	</body>
</html>
